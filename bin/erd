#!/bin/sh
# shellcheck disable=SC2004

# ERD (Exclusively Restart Dnsmasq)
# This script just restarts the Dnsmasq daemon, essentially, but keeps it from failing by maneuvering exclusively.

set -eu

LAST_UPDATE_FILE="/home/ubuntu/.tmp/restart_dnsmasq_last_update"
EXE_COUNT_FILE="/home/ubuntu/.tmp/restart_dnsmasq_exe_count"
TIME_THRESHOLD="11"
COUNT_THRESHOLD="5"
MAX_SLEEP_TIME="5"
XDG_RUNTIME_DIR="/run/user/$(id -u)"
export XDG_RUNTIME_DIR # for cron

main() {
  parse "$@"
  eval "set -- $REST"

  while [ "$(executable)" = "false" ]; do
    # do not encompass the variables (MAX_SLEEP_TIME) with double quotes
    sleep_time=$(( $(od -An -N1 -t u1 /dev/urandom) % $MAX_SLEEP_TIME + 1 ))
    echo "Restarting the daemon canceled because it's done many times in a row. Trying to restart the daemon in $sleep_time seconds..."
    sleep "$sleep_time"
  done

  if [ "$(executable)" = "true" ]; then
    sudo systemctl restart dnsmasq
    update_file
    print_debug_info "succeeded"
  else
    print_debug_info "failed"
  fi

  if [ "$(sudo systemctl is-active dnsmasq)" != "active" ]; then
    sudo systemctl restart dnsmasq
  fi

  [ "$LOG" != "" ] && echo "Restarted the daemon on $(date) (status: $(sudo systemctl is-active dnsmasq), from: $FROM)" >> "$LOG"
}

executable() {
  if ! [ -f "$LAST_UPDATE_FILE" ] && ! [ -f "$EXE_COUNT_FILE" ]; then
    echo "true"
  elif [ "$(( $(date +%s) - $(cat "$LAST_UPDATE_FILE") ))" -ge "$TIME_THRESHOLD" ]; then
    echo "true"
  elif [ "$(cat "$EXE_COUNT_FILE")" -lt "$COUNT_THRESHOLD" ]; then
    echo "true"
  else
    echo "false"
  fi
}

update_file() {
  if ! [ -f "$LAST_UPDATE_FILE" ]; then
    date +%s > "$LAST_UPDATE_FILE"
  fi

  if ! [ -f "$EXE_COUNT_FILE" ]; then
    echo "1" > "$EXE_COUNT_FILE"
    date +%s > "$LAST_UPDATE_FILE"
  elif [ "$(( $(date +%s) - $(cat "$LAST_UPDATE_FILE") ))" -ge "$TIME_THRESHOLD" ]; then
    echo "1" > "$EXE_COUNT_FILE"
    date +%s > "$LAST_UPDATE_FILE"
  elif [ "$(cat "$EXE_COUNT_FILE")" -lt "$COUNT_THRESHOLD" ]; then
    echo $(( $(cat "$EXE_COUNT_FILE") + 1 )) > "$EXE_COUNT_FILE"
  elif [ "$(cat "$EXE_COUNT_FILE")" -ge "$COUNT_THRESHOLD" ]; then
    echo "1" > "$EXE_COUNT_FILE"
    date +%s > "$LAST_UPDATE_FILE"
  fi
}

print_debug_info() {
  echo "Status:          $1"
  echo "Current time:    $(date +%s)"
  echo "Last update:     $(cat $LAST_UPDATE_FILE)"
  echo "Execution count: $(cat $EXE_COUNT_FILE)"
}

# @getoptions
parser_definition() {
  setup   REST help:usage -- "Usage: erd [options]... [arguments]..." ''
  msg -- 'Options:'
  #flag    FLAG    -f --flag                 -- "takes no arguments"
  param    LOG        --log                  -- "output the log to the specified file"
  param    FROM       --from                 -- "contain where this script is invoked to the log"
  #param   PARAM   -p --param                -- "takes one argument"
  #option  OPTION  -o --option on:"default"  -- "takes one optional argument"
  disp    :usage  -h --help
  disp    VERSION    --version
}
# @end

# @gengetoptions parser -i parser_definition parse
# Generated by getoptions (BEGIN)
# URL: https://github.com/ko1nksm/getoptions (v3.3.0)
LOG=''
FROM=''
REST=''
parse() {
  OPTIND=$(($#+1))
  while OPTARG= && [ $# -gt 0 ]; do
    case $1 in
      --?*=*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%%\=*}" "${OPTARG#*\=}"' ${1+'"$@"'}
        ;;
      --no-*|--without-*) unset OPTARG ;;
      -[h]?*) OPTARG=$1; shift
        eval 'set -- "${OPTARG%"${OPTARG#??}"}" -"${OPTARG#??}"' ${1+'"$@"'}
        OPTARG= ;;
    esac
    case $1 in
      '--log')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        LOG="$OPTARG"
        shift ;;
      '--from')
        [ $# -le 1 ] && set "required" "$1" && break
        OPTARG=$2
        FROM="$OPTARG"
        shift ;;
      '-h'|'--help')
        usage
        exit 0 ;;
      '--version')
        echo "${VERSION}"
        exit 0 ;;
      --)
        shift
        while [ $# -gt 0 ]; do
          REST="${REST} \"\${$(($OPTIND-$#))}\""
          shift
        done
        break ;;
      [-]?*) set "unknown" "$1"; break ;;
      *)
        REST="${REST} \"\${$(($OPTIND-$#))}\""
    esac
    shift
  done
  [ $# -eq 0 ] && { OPTIND=1; unset OPTARG; return 0; }
  case $1 in
    unknown) set "Unrecognized option: $2" "$@" ;;
    noarg) set "Does not allow an argument: $2" "$@" ;;
    required) set "Requires an argument: $2" "$@" ;;
    pattern:*) set "Does not match the pattern (${1#*:}): $2" "$@" ;;
    notcmd) set "Not a command: $2" "$@" ;;
    *) set "Validation error ($1): $2" "$@"
  esac
  echo "$1" >&2
  exit 1
}
usage() {
cat<<'GETOPTIONSHERE'
Usage: erd [options]... [arguments]...

Options:
      --log LOG               output the log to the specified file
      --from FROM             contain where this script is invoked to the log
  -h, --help
      --version
GETOPTIONSHERE
}
# Generated by getoptions (END)
# @end

main "$@"
